<!DOCTYPE html>
<html lang="eng">
<head>
<title>Regexp Man Page</title>
</head>
<HTML>
<BODY>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->

</PRE>
<H2>REGEXP REGULAR EXPRESSION DETAILS</H2><PRE>
       The syntax and semantics of the regular expressions that are supported by
       PCRE are described in detail below. There is a quick-reference syntax
       summary in the <B>pcresyntax</B> page. PCRE tries to match Perl syntax and
       semantics as closely as it can. PCRE also supports some alternative
       regular expression syntax (which does not conflict with the Perl syntax)
       in order to provide some compatibility with regular expressions in
       Python, .NET, and Oniguruma.

       Perl's regular expressions are described in its own documentation, and
       regular expressions in general are covered in a number of books, some of
       which have copious examples. Jeffrey Friedl's "Mastering Regular
       Expressions", published by O'Reilly, covers regular expressions in great
       detail. This description of PCRE's regular expressions is intended as
       reference material.

       The original operation of PCRE was on strings of one-byte characters.
       However, there is now also support for UTF-8 character strings. To use
       this, you must build PCRE to include UTF-8 support, and then call
       <B>pcre_compile()</B> with the PCRE_UTF8 option. How this affects pattern
       matching is mentioned in several places below. There is also a summary of
       UTF-8 features in the section on UTF-8 support in the main <B>pcre</B> page.

       The remainder of this document discusses the patterns that are supported
       by PCRE when its main matching function, <B>pcre_exec()</B>, is used.  From
       release 6.0, PCRE offers a second matching function, <B>pcre_dfa_exec()</B>,
       which matches using a different algorithm that is not Perl-compatible.
       Some of the features discussed below are not available when
       <B>pcre_dfa_exec()</B> is used. The advantages and disadvantages of the
       alternative function, and how it differs from the normal function, are
       discussed in the <B>pcrematching</B> page.


</PRE>
<H2>NEWLINE CONVENTIONS</H2><PRE>
       PCRE supports five different conventions for indicating line breaks in
       strings: a single CR (carriage return) character, a single LF (linefeed)
       character, the two-character sequence CRLF, any of the three preceding,
       or any Unicode newline sequence. The <B>pcreapi</B> page has further discussion
       about newlines, and shows how to set the newline convention in the
       <I>options</I> arguments for the compiling and matching functions.

       It is also possible to specify a newline convention by starting a pattern
       string with one of the following five sequences:

         (*CR)        carriage return
         (*LF)        linefeed
         (*CRLF)      carriage return, followed by linefeed
         (*ANYCRLF)   any of the three above
         (*ANY)       all Unicode newline sequences

       These override the default and the options given to <B>pcre_compile()</B>. For
       example, on a Unix system where LF is the default newline sequence, the
       pattern


</PRE>
<H2>CHARACTERS AND METACHARACTERS</H2><PRE>
       A regular expression is a pattern that is matched against a subject
       string from left to right. Most characters stand for themselves in a
       pattern, and match the corresponding characters in the subject. As a
       trivial example, the pattern

         The quick brown fox

       matches a portion of a subject string that is identical to itself. When
       caseless matching is specified (the PCRE_CASELESS option), letters are
       matched independently of case. In UTF-8 mode, PCRE always understands the
       concept of case for characters whose values are less than 128, so
       caseless matching is always possible. For characters with higher values,
       the concept of case is supported if PCRE is compiled with Unicode
       property support, but not otherwise.  If you want to use caseless
       matching for characters 128 and above, you must ensure that PCRE is
       compiled with Unicode property support as well as with UTF-8 support.

       The power of regular expressions comes from the ability to include
       alternatives and repetitions in the pattern. These are encoded in the
       pattern by the use of <I>metacharacters</I>, which do not stand for themselves
       but instead are interpreted in some special way.

       There are two different sets of metacharacters: those that are recognized
       anywhere in the pattern except within square brackets, and those that are
       recognized within square brackets. Outside square brackets, the
       metacharacters are as follows:

         \      general escape character with several uses
         ^      assert start of string (or line, in multiline mode)
         $      assert end of string (or line, in multiline mode)
         .      match any character except newline (by default)
         [      start character class definition
         |      start of alternative branch
         (      start subpattern
         )      end subpattern
         ?      extends the meaning of (
                also 0 or 1 quantifier
                also quantifier minimizer
         *      0 or more quantifier
         +      1 or more quantifier
                also "possessive quantifier"
         {      start min/max quantifier

       Part of a pattern that is in square brackets is called a "character
       class". In a character class the only metacharacters are:

         \      general escape character
         ^      negate the class, but only if the first character
         -      indicates character range
         [      POSIX character class (only if followed by POSIX

       always safe to precede a non-alphanumeric with backslash to specify that
       it stands for itself. In particular, if you want to match a backslash,
       you write \\.

       If a pattern is compiled with the PCRE_EXTENDED option, whitespace in the
       pattern (other than in a character class) and characters between a #
       outside a character class and the next newline are ignored. An escaping
       backslash can be used to include a whitespace or # character as part of
       the pattern.

       If you want to remove the special meaning from a sequence of characters,
       you can do so by putting them between \Q and \E. This is different from
       Perl in that $ and @ are handled as literals in \Q...\E sequences in
       PCRE, whereas in Perl, $ and @ cause variable interpolation. Note the
       following examples:

         Pattern            PCRE matches   Perl matches

         \Qabc$xyz\E        abc$xyz        abc followed by the
                                             contents of $xyz
         \Qabc\$xyz\E       abc\$xyz       abc\$xyz
         \Qabc\E\$\Qxyz\E   abc$xyz        abc$xyz

       The \Q...\E sequence is recognized both inside and outside character
       classes.

   <B>Non-printing</B> <B>characters</B>
       A second use of backslash provides a way of encoding non-printing
       characters in patterns in a visible manner. There is no restriction on
       the appearance of non-printing characters, apart from the binary zero
       that terminates a pattern, but when a pattern is being prepared by text
       editing, it is usually easier to use one of the following escape
       sequences than the binary character it represents:

         \a        alarm, that is, the BEL character (hex 07)
         \cx       "control-x", where x is any character
         \e        escape (hex 1B)
         \f        formfeed (hex 0C)
         \n        linefeed (hex 0A)
         \r        carriage return (hex 0D)
         \t        tab (hex 09)
         \ddd      character with octal code ddd, or backreference
         \xhh      character with hex code hh
         \x{hhh..} character with hex code hhh..

       The precise effect of \cx is as follows: if x is a lower case letter, it
       is converted to upper case. Then bit 6 of the character (hex 40) is
       inverted.  Thus \cz becomes hex 1A, but \c{ becomes hex 3B, while \c;
       becomes hex 7B.

       After \x, from zero to two hexadecimal digits are read (letters can be in
       upper or lower case). Any number of hexadecimal digits may appear between
       After \0 up to two further octal digits are read. If there are fewer than
       two digits, just those that are present are used. Thus the sequence
       \0\x\07 specifies two binary zeros followed by a BEL character (code
       value 7). Make sure you supply two digits after the initial zero if the
       pattern character that follows is itself an octal digit.

       The handling of a backslash followed by a digit other than 0 is
       complicated.  Outside a character class, PCRE reads it and any following
       digits as a decimal number. If the number is less than 10, or if there
       have been at least that many previous capturing left parentheses in the
       expression, the entire sequence is taken as a <I>back</I> <I>reference</I>. A
       description of how this works is given later, following the discussion of
       parenthesized subpatterns.

       Inside a character class, or if the decimal number is greater than 9 and
       there have not been that many capturing subpatterns, PCRE re-reads up to
       three octal digits following the backslash, and uses them to generate a
       data character. Any subsequent digits stand for themselves. In non-UTF-8
       mode, the value of a character specified in octal must be less than \400.
       In UTF-8 mode, values up to \777 are permitted. For example:

         \040   is another way of writing a space
         \40    is the same, provided there are fewer than 40
                   previous capturing subpatterns
         \7     is always a back reference
         \11    might be a back reference, or another way of
                   writing a tab
         \011   is always a tab
         \0113  is a tab followed by the character "3"
         \113   might be a back reference, otherwise the
                   character with octal code 113
         \377   might be a back reference, otherwise
                   the byte consisting entirely of 1 bits
         \81    is either a back reference, or a binary zero
                   followed by the two characters "8" and "1"

       Note that octal values of 100 or greater must not be introduced by a
       leading zero, because no more than three octal digits are ever read.

       All the sequences that define a single character value can be used both
       inside and outside character classes. In addition, inside a character
       class, the sequence \b is interpreted as the backspace character (hex
       08), and the sequences \R and \X are interpreted as the characters "R"
       and "X", respectively. Outside a character class, these sequences have
       different meanings (see below).

   <B>Absolute</B> <B>and</B> <B>relative</B> <B>back</B> <B>references</B>
       The sequence \g followed by an unsigned or a negative number, optionally
       enclosed in braces, is an absolute or relative back reference. A named
       back reference can be coded as \g{name}. Back references are discussed
       later, following the discussion of parenthesized subpatterns.

         \h     any horizontal whitespace character
         \H     any character that is not a horizontal whitespace character
         \s     any whitespace character
         \S     any character that is not a whitespace character
         \v     any vertical whitespace character
         \V     any character that is not a vertical whitespace character
         \w     any "word" character
         \W     any "non-word" character

       Each pair of escape sequences partitions the complete set of characters
       into two disjoint sets. Any given character matches one, and only one, of
       each pair.

       These character type sequences can appear both inside and outside
       character classes. They each match one character of the appropriate type.
       If the current matching point is at the end of the subject string, all of
       them fail, since there is no character to match.

       For compatibility with Perl, \s does not match the VT character (code
       11).  This makes it different from the the POSIX "space" class. The \s
       characters are HT (9), LF (10), FF (12), CR (13), and space (32). If "use
       locale;" is included in a Perl script, \s may match the VT character. In
       PCRE, it never does.

       In UTF-8 mode, characters with values greater than 128 never match \d,
       \s, or \w, and always match \D, \S, and \W. This is true even when
       Unicode character property support is available. These sequences retain
       their original meanings from before UTF-8 support was available, mainly
       for efficiency reasons.

       The sequences \h, \H, \v, and \V are Perl 5.10 features. In contrast to
       the other sequences, these do match certain high-valued codepoints in
       UTF-8 mode.  The horizontal space characters are:

         U+0009     Horizontal tab
         U+0020     Space
         U+00A0     Non-break space
         U+1680     Ogham space mark
         U+180E     Mongolian vowel separator
         U+2000     En quad
         U+2001     Em quad
         U+2002     En space
         U+2003     Em space
         U+2004     Three-per-em space
         U+2005     Four-per-em space
         U+2006     Six-per-em space
         U+2007     Figure space
         U+2008     Punctuation space
         U+2009     Thin space
         U+200A     Hair space
         U+202F     Narrow no-break space
         U+205F     Medium mathematical space

       by PCRE's low-valued character tables, and may vary if locale-specific
       matching is taking place (see "Locale support" in the <B>pcreapi</B> page). For
       example, in a French locale such as "fr_FR" in Unix-like systems, or
       "french" in Windows, some character codes greater than 128 are used for
       accented letters, and these are matched by \w. The use of locales with
       Unicode is discouraged.

   <B>Newline</B> <B>sequences</B>
       Outside a character class, by default, the escape sequence \R matches any
       Unicode newline sequence. This is a Perl 5.10 feature. In non-UTF-8 mode
       \R is equivalent to the following:

         (?&gt;;\r\n|\n|\x0b|\f|\r|\x85)

       This is an example of an "atomic group", details of which are given
       below.  This particular group matches either the two-character sequence
       CR followed by LF, or one of the single characters LF (linefeed, U+000A),
       VT (vertical tab, U+000B), FF (formfeed, U+000C), CR (carriage return,
       U+000D), or NEL (next line, U+0085). The two-character sequence is
       treated as a single unit that cannot be split.

       In UTF-8 mode, two additional characters whose codepoints are greater
       than 255 are added: LS (line separator, U+2028) and PS (paragraph
       separator, U+2029).  Unicode character property support is not needed for
       these characters to be recognized.

       It is possible to restrict \R to match only CR, LF, or CRLF (instead of
       the complete set of Unicode line endings) by setting the option
       PCRE_BSR_ANYCRLF either at compile time or when the pattern is matched.
       (BSR is an abbrevation for "backslash R".) This can be made the default
       when PCRE is built; if this is the case, the other behaviour can be
       requested via the PCRE_BSR_UNICODE option.  It is also possible to
       specify these settings by starting a pattern string with one of the
       following sequences:

         (*BSR_ANYCRLF)   CR, LF, or CRLF only
         (*BSR_UNICODE)   any Unicode newline sequence

       These override the default and the options given to <B>pcre_compile()</B>, but
       they can be overridden by options given to <B>pcre_exec()</B>. Note that these
       special settings, which are not Perl-compatible, are recognized only at
       the very start of a pattern, and that they must be in upper case. If more
       than one of them is present, the last one is used. They can be combined
       with a change of newline convention, for example, a pattern can start
       with:

         (*ANY)(*BSR_ANYCRLF)

       Inside a character class, \R matches the letter "R".

   <B>Unicode</B> <B>character</B> <B>properties</B>
       When PCRE is built with Unicode character property support, three

       Sets of Unicode characters are defined as belonging to certain scripts. A
       character from one of these sets can be matched using a script name. For
       example:

         \p{Greek}
         \P{Han}

       Those that are not part of an identified script are lumped together as
       "Common". The current list of scripts is:

       Arabic, Armenian, Balinese, Bengali, Bopomofo, Braille, Buginese, Buhid,
       Canadian_Aboriginal, Cherokee, Common, Coptic, Cuneiform, Cypriot,
       Cyrillic, Deseret, Devanagari, Ethiopic, Georgian, Glagolitic, Gothic,
       Greek, Gujarati, Gurmukhi, Han, Hangul, Hanunoo, Hebrew, Hiragana,
       Inherited, Kannada, Katakana, Kharoshthi, Khmer, Lao, Latin, Limbu,
       Linear_B, Malayalam, Mongolian, Myanmar, New_Tai_Lue, Nko, Ogham,
       Old_Italic, Old_Persian, Oriya, Osmanya, Phags_Pa, Phoenician, Runic,
       Shavian, Sinhala, Syloti_Nagri, Syriac, Tagalog, Tagbanwa, Tai_Le, Tamil,
       Telugu, Thaana, Thai, Tibetan, Tifinagh, Ugaritic, Yi.

       Each character has exactly one general category property, specified by a
       two-letter abbreviation. For compatibility with Perl, negation can be
       specified by including a circumflex between the opening brace and the
       property name. For example, \p{^Lu} is the same as \P{Lu}.

       If only one letter is specified with \p or \P, it includes all the
       general category properties that start with that letter. In this case, in
       the absence of negation, the curly brackets in the escape sequence are
       optional; these two examples have the same effect:

         \p{L}
         \pL

       The following general category property codes are supported:

         C     Other
         Cc    Control
         Cf    Format
         Cn    Unassigned
         Co    Private use
         Cs    Surrogate

         L     Letter
         Ll    Lower case letter
         Lm    Modifier letter
         Lo    Other letter
         Lt    Title case letter
         Lu    Upper case letter

         M     Mark
         Mc    Spacing mark
         Po    Other punctuation
         Ps    Open punctuation

         S     Symbol
         Sc    Currency symbol
         Sk    Modifier symbol
         Sm    Mathematical symbol
         So    Other symbol

         Z     Separator
         Zl    Line separator
         Zp    Paragraph separator
         Zs    Space separator

       The special property L&amp;; is also supported: it matches a character that
       has the Lu, Ll, or Lt property, in other words, a letter that is not
       classified as a modifier or "other".

       The Cs (Surrogate) property applies only to characters in the range
       U+D800 to U+DFFF. Such characters are not valid in UTF-8 strings (see RFC
       3629) and so cannot be tested by PCRE, unless UTF-8 validity checking has
       been turned off (see the discussion of PCRE_NO_UTF8_CHECK in the <B>pcreapi</B>
       page).

       The long synonyms for these properties that Perl supports (such as
       \p{Letter}) are not supported by PCRE, nor is it permitted to prefix any
       of these properties with "Is".

       No character that is in the Unicode table has the Cn (unassigned)
       property.  Instead, this property is assumed for any code point that is
       not in the Unicode table.

       Specifying caseless matching does not affect these escape sequences. For
       example, \p{Lu} always matches only upper case letters.

       The \X escape matches any number of Unicode characters that form an
       extended Unicode sequence. \X is equivalent to

         (?&gt;;\PM\pM*)

       That is, it matches a character without the "mark" property, followed by
       zero or more characters with the "mark" property, and treats the sequence
       as an atomic group (see below).  Characters with the "mark" property are
       typically accents that affect the preceding character. None of them have
       codepoints less than 256, so in non-UTF-8 mode \X matches any one
       character.

       Matching characters by Unicode property is not fast, because PCRE has to
       search a structure that contains data for over fifteen thousand
       characters. That is why the traditional escape sequences such as \d and
       \w do not use Unicode properties in PCRE.

         (foo)\Kbar

       matches "foobar", the first substring is still set to "foo".

   <B>Simple</B> <B>assertions</B>
       The final use of backslash is for certain simple assertions. An assertion
       specifies a condition that has to be met at a particular point in a
       match, without consuming any characters from the subject string. The use
       of subpatterns for more complicated assertions is described below.  The
       backslashed assertions are:

         \b     matches at a word boundary
         \B     matches when not at a word boundary
         \A     matches at the start of the subject
         \Z     matches at the end of the subject
                 also matches before a newline at the end of the subject
         \z     matches only at the end of the subject
         \G     matches at the first matching position in the subject

       These assertions may not appear in character classes (but note that \b
       has a different meaning, namely the backspace character, inside a
       character class).

       A word boundary is a position in the subject string where the current
       character and the previous character do not both match \w or \W (i.e. one
       matches \w and the other matches \W), or the start or end of the string
       if the first or last character matches \w, respectively.

       The \A, \Z, and \z assertions differ from the traditional circumflex and
       dollar (described in the next section) in that they only ever match at
       the very start and end of the subject string, whatever options are set.
       Thus, they are independent of multiline mode. These three assertions are
       not affected by the PCRE_NOTBOL or PCRE_NOTEOL options, which affect only
       the behaviour of the circumflex and dollar metacharacters. However, if
       the <I>startoffset</I> argument of <B>pcre_exec()</B> is non-zero, indicating that
       matching is to start at a point other than the beginning of the subject,
       \A can never match. The difference between \Z and \z is that \Z matches
       before a newline at the end of the string as well as at the very end,
       whereas \z matches only at the end.

       The \G assertion is true only when the current matching position is at
       the start point of the match, as specified by the <I>startoffset</I> argument of
       <B>pcre_exec()</B>. It differs from \A when the value of <I>startoffset</I> is non-
       zero. By calling <B>pcre_exec()</B> multiple times with appropriate arguments,
       you can mimic Perl's /g option, and it is in this kind of implementation
       where \G can be useful.

       Note, however, that PCRE's interpretation of \G, as the start of the
       current match, is subtly different from Perl's, which defines it as the
       end of the previous match. In Perl, these can be different when the
       previously matched string was empty. Because PCRE does just one match at
       a time, it cannot reproduce this behaviour.
       alternatives are involved, but it should be the first thing in each
       alternative in which it appears if the pattern is ever to match that
       branch. If all possible alternatives start with a circumflex, that is, if
       the pattern is constrained to match only at the start of the subject, it
       is said to be an "anchored" pattern. (There are also other constructs
       that can cause a pattern to be anchored.)

       A dollar character is an assertion that is true only if the current
       matching point is at the end of the subject string, or immediately before
       a newline at the end of the string (by default). Dollar need not be the
       last character of the pattern if a number of alternatives are involved,
       but it should be the last item in any branch in which it appears. Dollar
       has no special meaning in a character class.

       The meaning of dollar can be changed so that it matches only at the very
       end of the string, by setting the PCRE_DOLLAR_ENDONLY option at compile
       time. This does not affect the \Z assertion.

       The meanings of the circumflex and dollar characters are changed if the
       PCRE_MULTILINE option is set. When this is the case, a circumflex matches
       immediately after internal newlines as well as at the start of the
       subject string. It does not match after a newline that ends the string. A
       dollar matches before any newlines in the string, as well as at the very
       end, when PCRE_MULTILINE is set. When newline is specified as the two-
       character sequence CRLF, isolated CR and LF characters do not indicate
       newlines.

       For example, the pattern /^abc$/ matches the subject string "def\nabc"
       (where \n represents a newline) in multiline mode, but not otherwise.
       Consequently, patterns that are anchored in single line mode because all
       branches start with ^ are not anchored in multiline mode, and a match for
       circumflex is possible when the <I>startoffset</I> argument of <B>pcre_exec()</B> is
       non-zero. The PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is
       set.

       Note that the sequences \A, \Z, and \z can be used to match the start and
       end of the subject in both modes, and if all branches of a pattern start
       with \A it is always anchored, whether or not PCRE_MULTILINE is set.


</PRE>
<H2>FULL STOP (PERIOD, DOT)</H2><PRE>
       Outside a character class, a dot in the pattern matches any one character
       in the subject string except (by default) a character that signifies the
       end of a line. In UTF-8 mode, the matched character may be more than one
       byte long.

       When a line ending is defined as a single character, dot never matches
       that character; when the two-character sequence CRLF is used, dot does
       not match CR if it is immediately followed by LF, but otherwise it
       matches all characters (including isolated CRs and LFs). When any Unicode
       line endings are being recognized, dot does not match CR or LF or any of
       the other line ending characters.

       into individual bytes, what remains in the string may be a malformed
       UTF-8 string. For this reason, the \C escape sequence is best avoided.

       PCRE does not allow \C to appear in lookbehind assertions (described
       below), because in UTF-8 mode this would make it impossible to calculate
       the length of the lookbehind.


</PRE>
<H2>SQUARE BRACKETS AND CHARACTER CLASSES</H2><PRE>
       An opening square bracket introduces a character class, terminated by a
       closing square bracket. A closing square bracket on its own is not
       special. If a closing square bracket is required as a member of the
       class, it should be the first data character in the class (after an
       initial circumflex, if present) or escaped with a backslash.

       A character class matches a single character in the subject. In UTF-8
       mode, the character may occupy more than one byte. A matched character
       must be in the set of characters defined by the class, unless the first
       character in the class definition is a circumflex, in which case the
       subject character must not be in the set defined by the class. If a
       circumflex is actually required as a member of the class, ensure it is
       not the first character, or escape it with a backslash.

       For example, the character class [aeiou] matches any lower case vowel,
       while [^aeiou] matches any character that is not a lower case vowel. Note
       that a circumflex is just a convenient notation for specifying the
       characters that are in the class by enumerating those that are not. A
       class that starts with a circumflex is not an assertion: it still
       consumes a character from the subject string, and therefore it fails if
       the current pointer is at the end of the string.

       In UTF-8 mode, characters with values greater than 255 can be included in
       a class as a literal string of bytes, or by using the \x{ escaping
       mechanism.

       When caseless matching is set, any letters in a class represent both
       their upper case and lower case versions, so for example, a caseless
       [aeiou] matches "A" as well as "a", and a caseless [^aeiou] does not
       match "A", whereas a caseful version would. In UTF-8 mode, PCRE always
       understands the concept of case for characters whose values are less than
       128, so caseless matching is always possible. For characters with higher
       values, the concept of case is supported if PCRE is compiled with Unicode
       property support, but not otherwise.  If you want to use caseless
       matching for characters 128 and above, you must ensure that PCRE is
       compiled with Unicode property support as well as with UTF-8 support.

       Characters that might indicate line breaks are never treated in any
       special way when matching character classes, whatever line-ending
       sequence is in use, and whatever setting of the PCRE_DOTALL and
       PCRE_MULTILINE options is used. A class such as [^a] always matches one
       of these characters.

       The minus (hyphen) character can be used to specify a range of characters
       Ranges operate in the collating sequence of character values. They can
       also be used for characters specified numerically, for example
       [\000-\037]. In UTF-8 mode, ranges can include characters whose values
       are greater than 255, for example [\x{100}-\x{2ff}].

       If a range that includes letters is used when caseless matching is set,
       it matches the letters in either case. For example, [W-c] is equivalent
       to [][\\^_`wxyzabc], matched caselessly, and in non-UTF-8 mode, if
       character tables for a French locale are in use, [\xc8-\xcb] matches
       accented E characters in both cases. In UTF-8 mode, PCRE supports the
       concept of case for characters with values greater than 128 only when it
       is compiled with Unicode property support.

       The character types \d, \D, \p, \P, \s, \S, \w, and \W may also appear in
       a character class, and add the characters that they match to the class.
       For example, [\dABCDEF] matches any hexadecimal digit. A circumflex can
       conveniently be used with the upper case character types to specify a
       more restricted set of characters than the matching lower case type. For
       example, the class [^\W_] matches any letter or digit, but not
       underscore.

       The only metacharacters that are recognized in character classes are
       backslash, hyphen (only where it can be interpreted as specifying a
       range), circumflex (only at the start), opening square bracket (only when
       it can be interpreted as introducing a POSIX class name - see the next
       section), and the terminating closing square bracket. However, escaping
       other non-alphanumeric characters does no harm.


</PRE>
<H2>POSIX CHARACTER CLASSES</H2><PRE>
       Perl supports the POSIX notation for character classes. This uses names
       enclosed by [: and :] within the enclosing square brackets. PCRE also
       supports this notation. For example,

         [01[:alpha:]%]

       matches "0", "1", any alphabetic character, or "%". The supported class
       names are

         alnum    letters and digits
         alpha    letters
         ascii    character codes 0 - 127
         blank    space or tab only
         cntrl    control characters
         digit    decimal digits (same as \d)
         graph    printing characters, excluding space
         lower    lower case letters
         print    printing characters, including space
         punct    printing characters, excluding letters and digits
         space    white space (not quite the same as \s)
         upper    upper case letters
         word     "word" characters (same as \w)
         xdigit   hexadecimal digits

       these are not supported, and an error is given if they are encountered.

       In UTF-8 mode, characters with values greater than 128 do not match any
       of the POSIX character classes.


</PRE>
<H2>VERTICAL BAR</H2><PRE>
       Vertical bar characters are used to separate alternative patterns. For
       example, the pattern

         gilbert|sullivan

       matches either "gilbert" or "sullivan". Any number of alternatives may
       appear, and an empty alternative is permitted (matching the empty
       string). The matching process tries each alternative in turn, from left
       to right, and the first one that succeeds is used. If the alternatives
       are within a subpattern (defined below), "succeeds" means matching the
       rest of the main pattern as well as the alternative in the subpattern.


</PRE>
<H2>INTERNAL OPTION SETTING</H2><PRE>
       The settings of the PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, and
       PCRE_EXTENDED options (which are Perl-compatible) can be changed from
       within the pattern by a sequence of Perl option letters enclosed between
       "(?" and ")".  The option letters are

         i  for PCRE_CASELESS
         m  for PCRE_MULTILINE
         s  for PCRE_DOTALL
         x  for PCRE_EXTENDED

       For example, (?im) sets caseless, multiline matching. It is also possible
       to unset these options by preceding the letter with a hyphen, and a
       combined setting and unsetting such as (?im-sx), which sets PCRE_CASELESS
       and PCRE_MULTILINE while unsetting PCRE_DOTALL and PCRE_EXTENDED, is also
       permitted. If a letter appears both before and after the hyphen, the
       option is unset.

       The PCRE-specific options PCRE_DUPNAMES, PCRE_UNGREEDY, and PCRE_EXTRA
       can be changed in the same way as the Perl-compatible options by using
       the characters J, U and X respectively.

       When an option change occurs at top level (that is, not inside subpattern
       parentheses), the change applies to the remainder of the pattern that
       follows.  If the change is placed right at the start of a pattern, PCRE
       extracts it into the global options (and it will therefore show up in
       data extracted by the <B>pcre_fullinfo()</B> function).

       An option change within a subpattern (see below for a description of
       subpatterns) affects only that part of the current pattern that follows
       it, so

         (a(?i)b)c

       application when the compile or match functions are called. In some cases
       the pattern can contain special leading sequences to override what the
       application has set or what has been defaulted. Details are given in the
       section entitled "Newline sequences" above.


</PRE>
<H2>SUBPATTERNS</H2><PRE>
       Subpatterns are delimited by parentheses (round brackets), which can be
       nested.  Turning part of a pattern into a subpattern does two things:

       1. It localizes a set of alternatives. For example, the pattern

         cat(aract|erpillar|)

       matches one of the words "cat", "cataract", or "caterpillar". Without the
       parentheses, it would match "cataract", "erpillar" or an empty string.

       2. It sets up the subpattern as a capturing subpattern. This means that,
       when the whole pattern matches, that portion of the subject string that
       matched the subpattern is passed back to the caller via the <I>ovector</I>
       argument of <B>pcre_exec()</B>. Opening parentheses are counted from left to
       right (starting from 1) to obtain numbers for the capturing subpatterns.

       For example, if the string "the red king" is matched against the pattern

         the ((red|white) (king|queen))

       the captured substrings are "red king", "red", and "king", and are
       numbered 1, 2, and 3, respectively.

       The fact that plain parentheses fulfil two functions is not always
       helpful.  There are often times when a grouping subpattern is required
       without a capturing requirement. If an opening parenthesis is followed by
       a question mark and a colon, the subpattern does not do any capturing,
       and is not counted when computing the number of any subsequent capturing
       subpatterns. For example, if the string "the white queen" is matched
       against the pattern

         the ((?:red|white) (king|queen))

       the captured substrings are "white queen" and "queen", and are numbered 1
       and 2. The maximum number of capturing subpatterns is 65535.

       As a convenient shorthand, if any option settings are required at the
       start of a non-capturing subpattern, the option letters may appear
       between the "?" and the ":". Thus the two patterns

         (?i:saturday|sunday)
         (?:(?i)saturday|sunday)

       match exactly the same set of strings. Because alternative branches are
       tried from left to right, and options are not reset until the end of the
       subpattern is reached, an option setting in one branch does affect
       matched. This construct is useful when you want to capture part, but not
       all, of one of a number of alternatives. Inside a (?| group, parentheses
       are numbered as usual, but the number is reset at the start of each
       branch. The numbers of any capturing buffers that follow the subpattern
       start after the highest number used in any branch. The following example
       is taken from the Perl documentation.  The numbers underneath show in
       which buffer the captured content will be stored.

         # before  ---------------branch-reset----------- after
         / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
         # 1            2         2  3        2     3     4

       A backreference or a recursive call to a numbered subpattern always
       refers to the first one in the pattern with the given number.

       An alternative approach to using this "branch reset" feature is to use
       duplicate named subpatterns, as described in the next section.


</PRE>
<H2>NAMED SUBPATTERNS</H2><PRE>
       Identifying capturing parentheses by number is simple, but it can be very
       hard to keep track of the numbers in complicated regular expressions.
       Furthermore, if an expression is modified, the numbers may change. To
       help with this difficulty, PCRE supports the naming of subpatterns. This
       feature was not added to Perl until release 5.10. Python had the feature
       earlier, and PCRE introduced it at release 4.0, using the Python syntax.
       PCRE now supports both the Perl and the Python syntax.

       In PCRE, a subpattern can be named in one of three ways: (?&lt;;name&gt;;...) or
       (?'name'...) as in Perl, or (?P&lt;;name&gt;;...) as in Python. References to
       capturing parentheses from other parts of the pattern, such as
       backreferences, recursion, and conditions, can be made by name as well as
       by number.

       Names consist of up to 32 alphanumeric characters and underscores. Named
       capturing parentheses are still allocated numbers as well as names,
       exactly as if the names were not present. The PCRE API provides function
       calls for extracting the name-to-number translation table from a compiled
       pattern. There is also a convenience function for extracting a captured
       substring by name.

       By default, a name must be unique within a pattern, but it is possible to
       relax this constraint by setting the PCRE_DUPNAMES option at compile
       time. This can be useful for patterns where only one instance of the
       named parentheses can match. Suppose you want to match the name of a
       weekday, either as a 3-letter abbreviation or as the full name, and in
       both cases you want to extract the abbreviation. This pattern (ignoring
       the line breaks) does the job:

         (?&lt;;DN&gt;;Mon|Fri|Sun)(?:day)?|
         (?&lt;;DN&gt;;Tue)(?:sday)?|
         (?&lt;;DN&gt;;Wed)(?:nesday)?|
         (?&lt;;DN&gt;;Thu)(?:rsday)?|


</PRE>
<H2>REPETITION</H2><PRE>
       Repetition is specified by quantifiers, which can follow any of the
       following items:

         a literal data character
         the dot metacharacter
         the \C escape sequence
         the \X escape sequence (in UTF-8 mode with Unicode properties)
         the \R escape sequence
         an escape such as \d that matches a single character
         a character class
         a back reference (see next section)
         a parenthesized subpattern (unless it is an assertion)

       The general repetition quantifier specifies a minimum and maximum number
       of permitted matches, by giving the two numbers in curly brackets
       (braces), separated by a comma. The numbers must be less than 65536, and
       the first must be less than or equal to the second. For example:

         z{2,4}

       matches "zz", "zzz", or "zzzz". A closing brace on its own is not a
       special character. If the second number is omitted, but the comma is
       present, there is no upper limit; if the second number and the comma are
       both omitted, the quantifier specifies an exact number of required
       matches. Thus

         [aeiou]{3,}

       matches at least 3 successive vowels, but may match many more, while

         \d{8}

       matches exactly 8 digits. An opening curly bracket that appears in a
       position where a quantifier is not allowed, or one that does not match
       the syntax of a quantifier, is taken as a literal character. For example,
       {,6} is not a quantifier, but a literal string of four characters.

       In UTF-8 mode, quantifiers apply to UTF-8 characters rather than to
       individual bytes. Thus, for example, \x{100}{2} matches two UTF-8
       characters, each of which is represented by a two-byte sequence.
       Similarly, when Unicode property support is available, \X{3} matches
       three Unicode extended sequences, each of which may be several bytes long
       (and they may be of different lengths).

       The quantifier {0} is permitted, causing the expression to behave as if
       the previous item and the quantifier were not present. This may be useful
       for subpatterns that are referenced as subroutines from elsewhere in the
       pattern. Items other than subpatterns that have a {0} quantifier are
       omitted from the compiled pattern.

       For convenience, the three most common quantifiers have single-character
       useful, such patterns are now accepted, but if any repetition of the
       subpattern does in fact match no characters, the loop is forcibly broken.

       By default, the quantifiers are "greedy", that is, they match as much as
       possible (up to the maximum number of permitted times), without causing
       the rest of the pattern to fail. The classic example of where this gives
       problems is in trying to match comments in C programs. These appear
       between /* and */ and within the comment, individual * and / characters
       may appear. An attempt to match C comments by applying the pattern

         /\*.*\*/

       to the string

         /* first comment */  not comment  /* second comment */

       fails, because it matches the entire string owing to the greediness of
       the .* item.

       However, if a quantifier is followed by a question mark, it ceases to be
       greedy, and instead matches the minimum number of times possible, so the
       pattern

         /\*.*?\*/

       does the right thing with the C comments. The meaning of the various
       quantifiers is not otherwise changed, just the preferred number of
       matches.  Do not confuse this use of question mark with its use as a
       quantifier in its own right. Because it has two uses, it can sometimes
       appear doubled, as in

         \d??\d

       which matches one digit by preference, but can match two if that is the
       only way the rest of the pattern matches.

       If the PCRE_UNGREEDY option is set (an option that is not available in
       Perl), the quantifiers are not greedy by default, but individual ones can
       be made greedy by following them with a question mark. In other words, it
       inverts the default behaviour.

       When a parenthesized subpattern is quantified with a minimum repeat count
       that is greater than 1 or with a limited maximum, more memory is required
       for the compiled pattern, in proportion to the size of the minimum or
       maximum.

       If a pattern starts with .* or .{0,} and the PCRE_DOTALL option
       (equivalent to Perl's /s) is set, thus allowing the dot to match
       newlines, the pattern is implicitly anchored, because whatever follows
       will be tried against every character position in the subject string, so
       there is no point in retrying the overall match at any position after the
       first. PCRE normally treats such a pattern as though it were preceded by
       For this reason, such a pattern is not implicitly anchored.

       When a capturing subpattern is repeated, the value captured is the
       substring that matched the final iteration. For example, after

         (tweedle[dume]{3}\s*)+

       has matched "tweedledum tweedledee" the value of the captured substring
       is "tweedledee". However, if there are nested capturing subpatterns, the
       corresponding captured values may have been set in previous iterations.
       For example, after

         /(a|(b))+/

       matches "aba" the value of the second captured substring is "b".


</PRE>
<H2>ATOMIC GROUPING AND POSSESSIVE QUANTIFIERS</H2><PRE>
       With both maximizing ("greedy") and minimizing ("ungreedy" or "lazy")
       repetition, failure of what follows normally causes the repeated item to
       be re-evaluated to see if a different number of repeats allows the rest
       of the pattern to match. Sometimes it is useful to prevent this, either
       to change the nature of the match, or to cause it fail earlier than it
       otherwise might, when the author of the pattern knows there is no point
       in carrying on.

       Consider, for example, the pattern \d+foo when applied to the subject
       line

         123456bar

       After matching all 6 digits and then failing to match "foo", the normal
       action of the matcher is to try again with only 5 digits matching the \d+
       item, and then with 4, and so on, before ultimately failing. "Atomic
       grouping" (a term taken from Jeffrey Friedl's book) provides the means
       for specifying that once a subpattern has matched, it is not to be re-
       evaluated in this way.

       If we use atomic grouping for the previous example, the matcher gives up
       immediately on failing to match "foo" the first time. The notation is a
       kind of special parenthesis, starting with (?&gt;; as in this example:

         (?&gt;;\d+)foo

       This kind of parenthesis "locks up" the  part of the pattern it contains
       once it has matched, and a failure further into the pattern is prevented
       from backtracking into it. Backtracking past it to previous items,
       however, works as normal.

       An alternative description is that a subpattern of this type matches the
       string of characters that an identical standalone pattern would match, if
       anchored at the current point in the subject string.


       Note that a possessive quantifier can be used with an entire group, for
       example:

         (abc|xyz){2,3}+

       Possessive quantifiers are always greedy; the setting of the
       PCRE_UNGREEDY option is ignored. They are a convenient notation for the
       simpler forms of atomic group. However, there is no difference in the
       meaning of a possessive quantifier and the equivalent atomic group,
       though there may be a performance difference; possessive quantifiers
       should be slightly faster.

       The possessive quantifier syntax is an extension to the Perl 5.8 syntax.
       Jeffrey Friedl originated the idea (and the name) in the first edition of
       his book. Mike McCloskey liked it, so implemented it when he built Sun's
       Java package, and PCRE copied it from there. It ultimately found its way
       into Perl at release 5.10.

       PCRE has an optimization that automatically "possessifies" certain simple
       pattern constructs. For example, the sequence A+B is treated as A++B
       because there is no point in backtracking into a sequence of A's when B
       must follow.

       When a pattern contains an unlimited repeat inside a subpattern that can
       itself be repeated an unlimited number of times, the use of an atomic
       group is the only way to avoid some failing matches taking a very long
       time indeed. The pattern

         (\D+|&lt;;\d+&gt;;)*[!?]

       matches an unlimited number of substrings that either consist of non-
       digits, or digits enclosed in &lt;;&gt;;, followed by either ! or ?. When it
       matches, it runs quickly. However, if it is applied to

         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

       it takes a long time before reporting failure. This is because the string
       can be divided between the internal \D+ repeat and the external * repeat
       in a large number of ways, and all have to be tried. (The example uses
       [!?] rather than a single character at the end, because both PCRE and
       Perl have an optimization that allows for fast failure when a single
       character is used. They remember the last single character that is
       required for a match, and fail early if it is not present in the string.)
       If the pattern is changed so that it uses an atomic group, like this:

         ((?&gt;;\D+)|&lt;;\d+&gt;;)*[!?]

       sequences of non-digits cannot be broken, and failure happens quickly.


</PRE>
<H2>BACK REFERENCES</H2><PRE>
       Outside a character class, a backslash followed by a digit greater than 0
       sequence such as \50 is interpreted as a character defined in octal. See
       the subsection entitled "Non-printing characters" above for further
       details of the handling of digits following a backslash. There is no such
       problem when named parentheses are used. A back reference to any
       subpattern is possible using named parentheses (see below).

       Another way of avoiding the ambiguity inherent in the use of digits
       following a backslash is to use the \g escape sequence, which is a
       feature introduced in Perl 5.10. This escape must be followed by an
       unsigned number or a negative number, optionally enclosed in braces.
       These examples are all identical:

         (ring), \1
         (ring), \g1
         (ring), \g{1}

       An unsigned number specifies an absolute reference without the ambiguity
       that is present in the older syntax. It is also useful when literal
       digits follow the reference. A negative number is a relative reference.
       Consider this example:

         (abc(def)ghi)\g{-1}

       The sequence \g{-1} is a reference to the most recently started capturing
       subpattern before \g, that is, is it equivalent to \2. Similarly, \g{-2}
       would be equivalent to \1. The use of relative references can be helpful
       in long patterns, and also in patterns that are created by joining
       together fragments that contain references within themselves.

       A back reference matches whatever actually matched the capturing
       subpattern in the current subject string, rather than anything matching
       the subpattern itself (see "Subpatterns as subroutines" below for a way
       of doing that). So the pattern

         (sens|respons)e and \1ibility

       matches "sense and sensibility" and "response and responsibility", but
       not "sense and responsibility". If caseful matching is in force at the
       time of the back reference, the case of letters is relevant. For example,

         ((?i)rah)\s+\1

       matches "rah rah" and "RAH RAH", but not "RAH rah", even though the
       original capturing subpattern is matched caselessly.

       There are several different ways of writing back references to named
       subpatterns. The .NET syntax \k{name} and the Perl syntax \k&lt;;name&gt;; or
       \k'name' are supported, as is the Python syntax (?P=name). Perl 5.10's
       unified back reference syntax, in which \g can be used for both numeric
       and named references, is also supported. We could rewrite the above
       example in any of the following ways:

       always fails if it starts to match "a" rather than "bc". Because there
       may be many capturing parentheses in a pattern, all digits following the
       backslash are taken as part of a potential back reference number. If the
       pattern continues with a digit character, some delimiter must be used to
       terminate the back reference. If the PCRE_EXTENDED option is set, this
       can be whitespace.  Otherwise an empty comment (see "Comments" below) can
       be used.

       A back reference that occurs inside the parentheses to which it refers
       fails when the subpattern is first used, so, for example, (a\1) never
       matches.  However, such references can be useful inside repeated
       subpatterns. For example, the pattern

         (a|b\1)+

       matches any number of "a"s and also "aba", "ababbaa" etc. At each
       iteration of the subpattern, the back reference matches the character
       string corresponding to the previous iteration. In order for this to
       work, the pattern must be such that the first iteration does not need to
       match the back reference. This can be done using alternation, as in the
       example above, or by a quantifier with a minimum of zero.


</PRE>
<H2>ASSERTIONS</H2><PRE>
       An assertion is a test on the characters following or preceding the
       current matching point that does not actually consume any characters. The
       simple assertions coded as \b, \B, \A, \G, \Z, \z, ^ and $ are described
       above.

       More complicated assertions are coded as subpatterns. There are two
       kinds: those that look ahead of the current position in the subject
       string, and those that look behind it. An assertion subpattern is matched
       in the normal way, except that it does not cause the current matching
       position to be changed.

       Assertion subpatterns are not capturing subpatterns, and may not be
       repeated, because it makes no sense to assert the same thing several
       times. If any kind of assertion contains capturing subpatterns within it,
       these are counted for the purposes of numbering the capturing subpatterns
       in the whole pattern.  However, substring capturing is carried out only
       for positive assertions, because it does not make sense for negative
       assertions.

   <B>Lookahead</B> <B>assertions</B>
       Lookahead assertions start with (?= for positive assertions and (?! for
       negative assertions. For example,

         \w+(?=;)

       matches a word followed by a semicolon, but does not include the
       semicolon in the match, and

         foo(?!bar)

       must always fail.

   <B>Lookbehind</B> <B>assertions</B>
       Lookbehind assertions start with (?&lt;;= for positive assertions and (?&lt;;!
       for negative assertions. For example,

         (?&lt;;!foo)bar

       does find an occurrence of "bar" that is not preceded by "foo". The
       contents of a lookbehind assertion are restricted such that all the
       strings it matches must have a fixed length. However, if there are
       several top-level alternatives, they do not all have to have the same
       fixed length. Thus

         (?&lt;;=bullock|donkey)

       is permitted, but

         (?&lt;;!dogs?|cats?)

       causes an error at compile time. Branches that match different length
       strings are permitted only at the top level of a lookbehind assertion.
       This is an extension compared with Perl (at least for 5.8), which
       requires all branches to match the same length of string. An assertion
       such as

         (?&lt;;=ab(c|de))

       is not permitted, because its single top-level branch can match two
       different lengths, but it is acceptable if rewritten to use two top-level
       branches:

         (?&lt;;=abc|abde)

       In some cases, the Perl 5.10 escape sequence \K (see above) can be used
       instead of a lookbehind assertion; this is not restricted to a fixed-
       length.

       The implementation of lookbehind assertions is, for each alternative, to
       temporarily move the current position back by the fixed length and then
       try to match. If there are insufficient characters before the current
       position, the assertion fails.

       PCRE does not allow the \C escape (which matches a single byte in UTF-8
       mode) to appear in lookbehind assertions, because it makes it impossible
       to calculate the length of the lookbehind. The \X and \R escapes, which
       can match different numbers of bytes, are also not permitted.

       Possessive quantifiers can be used in conjunction with lookbehind
       assertions to specify efficient matching at the end of the subject
       string. Consider a simple pattern such as


         ^.*+(?&lt;;=abcd)

       there can be no backtracking for the .*+ item; it can match only the
       entire string. The subsequent lookbehind assertion does a single test on
       the last four characters. If it fails, the match fails immediately. For
       long strings, this approach makes a significant difference to the
       processing time.

   <B>Using</B> <B>multiple</B> <B>assertions</B>
       Several assertions (of any sort) may occur in succession. For example,

         (?&lt;;=\d{3})(?&lt;;!999)foo

       matches "foo" preceded by three digits that are not "999". Notice that
       each of the assertions is applied independently at the same point in the
       subject string. First there is a check that the previous three characters
       are all digits, and then there is a check that the same three characters
       are not "999".  This pattern does <I>not</I> match "foo" preceded by six
       characters, the first of which are digits and the last three of which are
       not "999". For example, it doesn't match "123abcfoo". A pattern to do
       that is

         (?&lt;;=\d{3}...)(?&lt;;!999)foo

       This time the first assertion looks at the preceding six characters,
       checking that the first three are digits, and then the second assertion
       checks that the preceding three characters are not "999".

       Assertions can be nested in any combination. For example,

         (?&lt;;=(?&lt;;!foo)bar)baz

       matches an occurrence of "baz" that is preceded by "bar" which in turn is
       not preceded by "foo", while

         (?&lt;;=\d{3}(?!999)...)foo

       is another pattern that matches "foo" preceded by three digits and any
       three characters that are not "999".


</PRE>
<H2>CONDITIONAL SUBPATTERNS</H2><PRE>
       It is possible to cause the matching process to obey a subpattern
       conditionally or to choose between two alternative subpatterns, depending
       on the result of an assertion, or whether a previous capturing subpattern
       matched or not. The two possible forms of conditional subpattern are

         (?(condition)yes-pattern)
         (?(condition)yes-pattern|no-pattern)

       If the condition is satisfied, the yes-pattern is used; otherwise the no-
       pattern (if present) is used. If there are more than two alternatives in

       Consider the following pattern, which contains non-significant white
       space to make it more readable (assume the PCRE_EXTENDED option) and to
       divide it into three parts for ease of discussion:

         ( \( )?    [^()]+    (?(1) \) )

       The first part matches an optional opening parenthesis, and if that
       character is present, sets it as the first captured substring. The second
       part matches one or more characters that are not parentheses. The third
       part is a conditional subpattern that tests whether the first set of
       parentheses matched or not. If they did, that is, if subject started with
       an opening parenthesis, the condition is true, and so the yes-pattern is
       executed and a closing parenthesis is required. Otherwise, since no-
       pattern is not present, the subpattern matches nothing. In other words,
       this pattern matches a sequence of non-parentheses, optionally enclosed
       in parentheses.

       If you were embedding this pattern in a larger one, you could use a
       relative reference:

         ...other stuff... ( \( )?    [^()]+    (?(-1) \) ) ...

       This makes the fragment independent of the parentheses in the larger
       pattern.

   <B>Checking</B> <B>for</B> <B>a</B> <B>used</B> <B>subpattern</B> <B>by</B> <B>name</B>
       Perl uses the syntax (?(&lt;;name&gt;;)...) or (?('name')...) to test for a used
       subpattern by name. For compatibility with earlier versions of PCRE,
       which had this facility before Perl, the syntax (?(name)...) is also
       recognized. However, there is a possible ambiguity with this syntax,
       because subpattern names may consist entirely of digits. PCRE looks first
       for a named subpattern; if it cannot find one and the name consists
       entirely of digits, PCRE looks for a subpattern of that number, which
       must be greater than zero. Using subpattern names that consist entirely
       of digits is not recommended.

       Rewriting the above example to use a named subpattern gives this:

         (?&lt;;OPEN&gt;; \( )?    [^()]+    (?(&lt;;OPEN&gt;;) \) )


   <B>Checking</B> <B>for</B> <B>pattern</B> <B>recursion</B>
       If the condition is the string (R), and there is no subpattern with the
       name R, the condition is true if a recursive call to the whole pattern or
       any subpattern has been made. If digits or a name preceded by ampersand
       follow the letter R, for example:

         (?(R3)...) or (?(R&amp;;name)...)

       the condition is true if the most recent recursion is into the subpattern
       whose number or name is given. This condition does not check the entire

         (?(DEFINE) (?&lt;;byte&gt;; 2[0-4]\d | 25[0-5] | 1\d\d | [1-9]?\d) )
         \b (?&amp;;byte) (\.(?&amp;;byte)){3} \b

       The first part of the pattern is a DEFINE group inside which a another
       group named "byte" is defined. This matches an individual component of an
       IPv4 address (a number less than 256). When matching takes place, this
       part of the pattern is skipped because DEFINE acts like a false
       condition.

       The rest of the pattern uses references to the named group to match the
       four dot-separated components of an IPv4 address, insisting on a word
       boundary at each end.

   <B>Assertion</B> <B>conditions</B>
       If the condition is not in any of the above formats, it must be an
       assertion.  This may be a positive or negative lookahead or lookbehind
       assertion. Consider this pattern, again containing non-significant white
       space, and with the two alternatives on the second line:

         (?(?=[^a-z]*[a-z])
         \d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )

       The condition is a positive lookahead assertion that matches an optional
       sequence of non-letters followed by a letter. In other words, it tests
       for the presence of at least one letter in the subject. If a letter is
       found, the subject is matched against the first alternative; otherwise it
       is matched against the second. This pattern matches strings in one of the
       two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.


</PRE>
<H2>COMMENTS</H2><PRE>
       The sequence (?# marks the start of a comment that continues up to the
       next closing parenthesis. Nested parentheses are not permitted. The
       characters that make up a comment play no part in the pattern matching at
       all.

       If the PCRE_EXTENDED option is set, an unescaped # character outside a
       character class introduces a comment that continues to immediately after
       the next newline in the pattern.


</PRE>
<H2>RECURSIVE PATTERNS</H2><PRE>
       Consider the problem of matching a string in parentheses, allowing for
       unlimited nested parentheses. Without the use of recursion, the best that
       can be done is to use a pattern that matches up to some fixed depth of
       nesting. It is not possible to handle an arbitrary nesting depth.

       For some time, Perl has provided a facility that allows regular
       expressions to recurse (amongst other things). It does this by
       interpolating Perl code in the expression at run time, and the code can
       refer to the expression itself. A Perl pattern using code interpolation
       to solve the parentheses problem can be created like this:

       special item (?R) or (?0) is a recursive call of the entire regular
       expression.

       In PCRE (like Python, but unlike Perl), a recursive subpattern call is
       always treated as an atomic group. That is, once it has matched some of
       the subject string, it is never re-entered, even if it contains untried
       alternatives and there is a subsequent matching failure.

       This PCRE pattern solves the nested parentheses problem (assume the
       PCRE_EXTENDED option is set so that white space is ignored):

         \( ( (?&gt;;[^()]+) | (?R) )* \)

       First it matches an opening parenthesis. Then it matches any number of
       substrings which can either be a sequence of non-parentheses, or a
       recursive match of the pattern itself (that is, a correctly parenthesized
       substring).  Finally there is a closing parenthesis.

       If this were part of a larger pattern, you would not want to recurse the
       entire pattern, so instead you could use this:

         ( \( ( (?&gt;;[^()]+) | (?1) )* \) )

       We have put the pattern into parentheses, and caused the recursion to
       refer to them instead of the whole pattern.

       In a larger pattern, keeping track of parenthesis numbers can be tricky.
       This is made easier by the use of relative references. (A Perl 5.10
       feature.)  Instead of (?1) in the pattern above you can write (?-2) to
       refer to the second most recently opened parentheses preceding the
       recursion. In other words, a negative number counts capturing parentheses
       leftwards from the point at which it is encountered.

       It is also possible to refer to subsequently opened parentheses, by
       writing references such as (?+2). However, these cannot be recursive
       because the reference is not inside the parentheses that are referenced.
       They are always "subroutine" calls, as described in the next section.

       An alternative approach is to use named parentheses instead. The Perl
       syntax for this is (?&amp;;name); PCRE's earlier syntax (?P&gt;;name) is also
       supported. We could rewrite the above example as follows:

         (?&lt;;pn&gt;; \( ( (?&gt;;[^()]+) | (?&amp;;pn) )* \) )

       If there is more than one subpattern with the same name, the earliest one
       is used.

       This particular example pattern that we have been looking at contains
       nested unlimited repeats, and so the use of atomic grouping for matching
       strings of non-parentheses is important when applying the pattern to
       strings that do not match. For example, when this pattern is applied to


       the value for the capturing parentheses is "ef", which is the last value
       taken on at the top level. If additional parentheses are added, giving

         \( ( ( (?&gt;;[^()]+) | (?R) )* ) \)
            ^                        ^
            ^                        ^

       the string they capture is "ab(cd)ef", the contents of the top level
       parentheses. If there are more than 15 capturing parentheses in a
       pattern, PCRE has to obtain extra memory to store data during a
       recursion, which it does by using <B>pcre_malloc</B>, freeing it via <B>pcre_free</B>
       afterwards. If no memory can be obtained, the match fails with the
       PCRE_ERROR_NOMEMORY error.

       Do not confuse the (?R) item with the condition (R), which tests for
       recursion.  Consider this pattern, which matches text in angle brackets,
       allowing for arbitrary nesting. Only digits are allowed in nested
       brackets (that is, when recursing), whereas any characters are permitted
       at the outer level.

         &lt;; (?: (?(R) \d++  | [^&lt;;&gt;;]*+) | (?R)) * &gt;;

       In this pattern, (?(R) is the start of a conditional subpattern, with two
       different alternatives for the recursive and non-recursive cases. The
       (?R) item is the actual recursive call.


</PRE>
<H2>SUBPATTERNS AS SUBROUTINES</H2><PRE>
       If the syntax for a recursive subpattern reference (either by number or
       by name) is used outside the parentheses to which it refers, it operates
       like a subroutine in a programming language. The "called" subpattern may
       be defined before or after the reference. A numbered reference can be
       absolute or relative, as in these examples:

         (...(absolute)...)...(?2)...
         (...(relative)...)...(?-1)...
         (...(?+1)...(relative)...

       An earlier example pointed out that the pattern

         (sens|respons)e and \1ibility

       matches "sense and sensibility" and "response and responsibility", but
       not "sense and responsibility". If instead the pattern

         (sens|respons)e and (?1)ibility

       is used, it does match "sense and responsibility" as well as the other
       two strings. Another example is given in the discussion of DEFINE above.

       Like recursive subpatterns, a "subroutine" call is always treated as an
       atomic group. That is, once it has matched some of the subject string, it
       name or a number enclosed either in angle brackets or single quotes, is
       an alternative syntax for referencing a subpattern as a subroutine,
       possibly recursively. Here are two of the examples used above, rewritten
       using this syntax:

         (?&lt;;pn&gt;; \( ( (?&gt;;[^()]+) | \g&lt;;pn&gt;; )* \) )
         (sens|respons)e and \g'1'ibility

       PCRE supports an extension to Oniguruma: if a number is preceded by a
       plus or a minus sign it is taken as a relative reference. For example:

         (abc)(?i:\g&lt;;-1&gt;;)

       Note that \g{...} (Perl syntax) and \g&lt;;...&gt;; (Oniguruma syntax) are <I>not</I>
       synonymous. The former is a back reference; the latter is a subroutine
       call.


</PRE>
<H2>CALLOUTS</H2><PRE>
       Perl has a feature whereby using the sequence (?{...}) causes arbitrary
       Perl code to be obeyed in the middle of matching a regular expression.
       This makes it possible, amongst other things, to extract different
       substrings that match the same pair of parentheses when there is a
       repetition.

       PCRE provides a similar feature, but of course it cannot obey arbitrary
       Perl code. The feature is called "callout". The caller of PCRE provides
       an external function by putting its entry point in the global variable
       <I>pcre</I><B>_</B><I>callout</I>.  By default, this variable contains NULL, which disables
       all calling out.

       Within a regular expression, (?C) indicates the points at which the
       external function is to be called. If you want to identify different
       callout points, you can put a number less than 256 after the letter C.
       The default value is zero.  For example, this pattern has two callout
       points:

         (?C1)abc(?C2)def

       If the PCRE_AUTO_CALLOUT flag is passed to <B>pcre_compile()</B>, callouts are
       automatically installed before each item in the pattern. They are all
       numbered 255.

       During matching, when PCRE reaches a callout point (and <I>pcre</I><B>_</B><I>callout</I> is
       set), the external function is called. It is provided with the number of
       the callout, the position in the pattern, and, optionally, one item of
       data originally supplied by the caller of <B>pcre_exec()</B>. The callout
       function may cause matching to proceed, to backtrack, or to fail
       altogether. A complete description of the interface to the callout
       function is given in the <B>pcrecallout</B> documentation.


</PRE>
<H2>BACKTRACKING CONTROL</H2><PRE>
       Perl 5.10 introduced a number of "Special Backtracking Control Verbs",
       form (*VERB:ARG) but PCRE does not support the use of arguments, so its
       general form is just (*VERB). Any number of these verbs may occur in a
       pattern. There are two kinds:

   <B>Verbs</B> <B>that</B> <B>act</B> <B>immediately</B>
       The following verbs act as soon as they are encountered:

          (*ACCEPT)

       This verb causes the match to end successfully, skipping the remainder of
       the pattern. When inside a recursion, only the innermost pattern is ended
       immediately. PCRE differs from Perl in what happens if the (*ACCEPT) is
       inside capturing parentheses. In Perl, the data so far is captured: in
       PCRE no data is captured. For example:

         A(A|B(*ACCEPT)|C)D

       This matches "AB", "AAD", or "ACD", but when it matches "AB", no data is
       captured.

         (*FAIL) or (*F)

       This verb causes the match to fail, forcing backtracking to occur. It is
       equivalent to (?!) but easier to read. The Perl documentation notes that
       it is probably useful only when combined with (?{}) or (??{}). Those are,
       of course, Perl features that are not present in PCRE. The nearest
       equivalent is the callout feature, as for example in this pattern:

         a+(?C)(*FAIL)

       A match with the string "aaaa" always fails, but the callout is taken
       before each backtrack happens (in this example, 10 times).

   <B>Verbs</B> <B>that</B> <B>act</B> <B>after</B> <B>backtracking</B>
       The following verbs do nothing when they are encountered. Matching
       continues with what follows, but if there is no subsequent match, a
       failure is forced.  The verbs differ in exactly what kind of failure
       occurs.

         (*COMMIT)

       This verb causes the whole match to fail outright if the rest of the
       pattern does not match. Even if the pattern is unanchored, no further
       attempts to find a match by advancing the start point take place. Once
       (*COMMIT) has been passed, <B>pcre_exec()</B> is committed to finding a match at
       the current starting point, or not at all. For example:

         a+(*COMMIT)b

       This matches "xxaab" but not "aacaab". It can be thought of as a kind of
       dynamic anchor, or "I've started, so I must finish."

       This verb is like (*PRUNE), except that if the pattern is unanchored, the
       "bumpalong" advance is not to the next character, but to the position in
       the subject where (*SKIP) was encountered. (*SKIP) signifies that
       whatever text was matched leading up to it cannot be part of a successful
       match. Consider:

         a+(*SKIP)b

       If the subject is "aaaac...", after the first match attempt fails
       (starting at the first character in the string), the starting point skips
       on to start the next attempt at "c". Note that a possessive quantifer
       does not have the same effect in this example; although it would suppress
       backtracking during the first match attempt, the second attempt would
       start at the second character instead of skipping on to "c".

         (*THEN)

       This verb causes a skip to the next alternation if the rest of the
       pattern does not match. That is, it cancels pending backtracking, but
       only within the current alternation. Its name comes from the observation
       that it can be used for a pattern-based if-then-else block:

         ( COND1 (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ ) ...

       If the COND1 pattern matches, FOO is tried (and possibly further items
       after the end of the group if FOO succeeds); on failure the matcher skips
       to the second alternative and tries COND2, without backtracking into
       COND1. If (*THEN) is used outside of any alternation, it acts exactly
       like (*PRUNE).


</PRE>
<H2>SEE ALSO</H2><PRE>
       <B>pcreapi(3)</B>, <B>pcrecallout(3)</B>, <B>pcrematching(3)</B>, <B>pcre(3)</B>.


</PRE>
<H2>AUTHOR</H2><PRE>
       Philip Hazel
       University Computing Service
       Cambridge CB2 3QH, England.


</PRE>
<H2>REVISION</H2><PRE>
       Last updated: 19 April 2008
       Copyright (c) 1997-2008 University of Cambridge.



                                                                  <B>PCREPATTERN(3)</B>
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
</html>